#!/usr/bin/env python3
import sys
from pathlib import Path
from operator import ior, iand
from functools import reduce
from itertools import accumulate
from typing import Set, Dict, List
from time import monotonic

FILENAME = Path("~/Downloads/words.txt").expanduser()
WORD_LENGTH = 5
DEBUG = True

def analyze(filenames: List[Path], word_length) -> None:
    letter_set: Set[str] = set()
    cwords: Dict[str, List[str]] = {}

    load_time = monotonic()
    words_seen: Set[str] = set()
    for filename in filenames:
        with open(filename) as file:
            for word in file:
                word = word.strip()
                if len(word) != word_length or not word.isalpha():
                    continue
                cset = set(word.lower())
                if len(cset) != word_length or word in words_seen:
                    continue
                words_seen.add(word)
                cword = "".join(sorted(cset))
                if cword not in cwords:
                    cwords[cword] = []
                    letter_set |= cset
                cwords[cword].append(word)

    letters = "".join(sorted(letter_set))
    print(f"{len(letters)} letters:", letters, file=sys.stderr)
    nr_words = len(letters) // word_length
    if nr_words <= 1:
        assert nr_words == 1
        raise NotImplementedError("{nr_words=} is not supported (and trivial)")
    nr_words1 = nr_words - 1
    letter_bits = { letter: 1 << i for i, letter in enumerate(letters) }
    bwords = { reduce(ior, (letter_bits[l] for l in cword)): cword for cword in cwords }

    def to_word(bword: int) -> str:
        return cwords[bwords[bword]][0]

    nr_bwords = len(bwords)
    assert nr_bwords == len(cwords)
    print(f"{len(words_seen)} words, {nr_bwords} unique anagrams", file = sys.stderr)
    # Starting with relatively isolated nodes is a LOT faster
    bword_keys = { bword: sum(b & bword == 0 for b in bwords) for bword in bwords}
    # print(bword_keys)
    bword_list = sorted(bwords, key = lambda x: bword_keys[x])
    # print(list(map(to_word, bword_list)), sys=stderr)

    base_time = monotonic()
    print(f"Prepare after {base_time - load_time:4.1f}s", file = sys.stderr)
    follows: Dict[int, List[List[int]]] = {}
    bit_need = nr_words1 * word_length
    empty = [[] for i in range(nr_words1)]
    best_bits: Dict[str, Dict[str, int]] = {}
    for i, bword in enumerate(bword_list):
        # print("Checking", to_word(bword))
        rfollow = [bword2 for bword2 in bword_list[:i:-1] if bword & bword2 == 0]
        # print("  rfollow", list(map(to_word, rfollow)))
        # if len(rfollow) < nr_words1:
        #    # Not enough candidates to make a clique
        #    follows[bword] = empty
        #    continue
        used = list(accumulate(rfollow, func=ior))
        best_bits[bword] = dict(zip(rfollow, used))
        used = [bin(use).count("1") for use in used]
        # print(f"  {used=}")
        #if bin(used[-1]).count("1") < bit_need:
        #    # Not enough candidates to make a clique
        #    follows[bword] = []
        #    continue

        follow_list = [[] for i in range(nr_words1)]
        for bword2, use in zip(rfollow, used):
            for i in range(0-use // word_length, 0):
                follow_list[i].append(bword2)
        # Reverse
        for rfollow in follow_list:
            rfollow.reverse()
        # print("  follow_list ", [list(map(to_word, rfollow)) for rfollow in follow_list])
        follows[bword] = follow_list

    if DEBUG:
        pass
        #for bword in bword_list:
        #    follow = follows[bword]
        #    words = list(map(to_word, follow))
        #    print(f"{to_word(bword)}:", words)

    start_time = monotonic()
    def explore(i, selected, used_letters):
        # print(f"{'  '*i}explore({i=}, {list(map(to_word, selected[:i+1]))})")
        left = nr_words1 - i
        if left == 0:
            words = list(map(to_word, selected))
            elapsed = monotonic() - start_time
            print(f"{elapsed:7.1f}: {words}")
            return

        bword = selected[i]
        if i == 0:
            # For i == 0 the preparation already guarantees the i != 0 tests
            for bword2 in follows[bword][i]:
                selected[i+1] = bword2
                explore(i+1, selected, used_letters | bword2)
            return

        #bbits = best_bits[selected[0]]
        # follow = [bword2 for bword2 in follows[bword][i] if bword2 & used_letters == 0 and bin(reduce(iand, (best_bits[selected[j]][bword2] for j in range(0, i+1))) & ~used_letters).count('1') >= bit_need]
        # if left == 1:
        #    # We are guaranteed word_length unused bits
        for bword2 in follows[bword][i]:
            if bword2 & used_letters == 0:
                selected[i+1] = bword2
                explore(i+1, selected, used_letters | bword2)

    selected = [0] * nr_words
    print(f"Start after {start_time - base_time:4.1f}s", file = sys.stderr)
    for i, bword in enumerate(bword_list):
        # print(f"{monotonic()-start_time:7.1f}s: {i=}", file = sys.stderr)
        selected[0] = bword
        explore(0, selected, bword)

if __name__ == '__main__':
    sys.stdout.reconfigure(line_buffering = True)
    analyze(sys.argv[1:] or [FILENAME], WORD_LENGTH)
